{"version":3,"file":"index-B9hW01HI.js","sources":["../../node_modules/is-node-process/lib/index.mjs","../../node_modules/@vercel/blob/dist/stream-browser.js","../../node_modules/is-buffer/index.js","../../node_modules/retry/lib/retry_operation.js","../../node_modules/retry/lib/retry.js","../../node_modules/retry/index.js","../../node_modules/async-retry/lib/index.js","../../node_modules/@vercel/blob/dist/undici-browser.js","../../node_modules/throttleit/index.js","../../node_modules/@vercel/blob/dist/chunk-Z56QURM6.js","../../node_modules/@vercel/blob/dist/index.js"],"sourcesContent":["// src/index.ts\nfunction isNodeProcess() {\n  if (typeof navigator !== \"undefined\" && navigator.product === \"ReactNative\") {\n    return true;\n  }\n  if (typeof process !== \"undefined\") {\n    const type = process.type;\n    if (type === \"renderer\" || type === \"worker\") {\n      return false;\n    }\n    return !!(process.versions && process.versions.node);\n  }\n  return false;\n}\nexport {\n  isNodeProcess\n};\n//# sourceMappingURL=index.mjs.map","// This file is here because Edge Functions have no support for Node.js streams by default\n// It's unlikely someone would try to read/use a Node.js stream in an Edge function but we still put\n// a message in case this happens\n\nexport const Readable = {\n  toWeb() {\n    throw new Error(\n      'Vercel Blob: Sorry, we cannot get a Readable stream in this environment. If you see this message please open an issue here: https://github.com/vercel/storage/ with details on your environment.',\n    );\n  },\n};\n","/*!\n * Determine if an object is a Buffer\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n\nmodule.exports = function isBuffer (obj) {\n  return obj != null && obj.constructor != null &&\n    typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)\n}\n","function RetryOperation(timeouts, options) {\n  // Compatibility for the old (timeouts, retryForever) signature\n  if (typeof options === 'boolean') {\n    options = { forever: options };\n  }\n\n  this._originalTimeouts = JSON.parse(JSON.stringify(timeouts));\n  this._timeouts = timeouts;\n  this._options = options || {};\n  this._maxRetryTime = options && options.maxRetryTime || Infinity;\n  this._fn = null;\n  this._errors = [];\n  this._attempts = 1;\n  this._operationTimeout = null;\n  this._operationTimeoutCb = null;\n  this._timeout = null;\n  this._operationStart = null;\n  this._timer = null;\n\n  if (this._options.forever) {\n    this._cachedTimeouts = this._timeouts.slice(0);\n  }\n}\nmodule.exports = RetryOperation;\n\nRetryOperation.prototype.reset = function() {\n  this._attempts = 1;\n  this._timeouts = this._originalTimeouts.slice(0);\n}\n\nRetryOperation.prototype.stop = function() {\n  if (this._timeout) {\n    clearTimeout(this._timeout);\n  }\n  if (this._timer) {\n    clearTimeout(this._timer);\n  }\n\n  this._timeouts       = [];\n  this._cachedTimeouts = null;\n};\n\nRetryOperation.prototype.retry = function(err) {\n  if (this._timeout) {\n    clearTimeout(this._timeout);\n  }\n\n  if (!err) {\n    return false;\n  }\n  var currentTime = new Date().getTime();\n  if (err && currentTime - this._operationStart >= this._maxRetryTime) {\n    this._errors.push(err);\n    this._errors.unshift(new Error('RetryOperation timeout occurred'));\n    return false;\n  }\n\n  this._errors.push(err);\n\n  var timeout = this._timeouts.shift();\n  if (timeout === undefined) {\n    if (this._cachedTimeouts) {\n      // retry forever, only keep last error\n      this._errors.splice(0, this._errors.length - 1);\n      timeout = this._cachedTimeouts.slice(-1);\n    } else {\n      return false;\n    }\n  }\n\n  var self = this;\n  this._timer = setTimeout(function() {\n    self._attempts++;\n\n    if (self._operationTimeoutCb) {\n      self._timeout = setTimeout(function() {\n        self._operationTimeoutCb(self._attempts);\n      }, self._operationTimeout);\n\n      if (self._options.unref) {\n          self._timeout.unref();\n      }\n    }\n\n    self._fn(self._attempts);\n  }, timeout);\n\n  if (this._options.unref) {\n      this._timer.unref();\n  }\n\n  return true;\n};\n\nRetryOperation.prototype.attempt = function(fn, timeoutOps) {\n  this._fn = fn;\n\n  if (timeoutOps) {\n    if (timeoutOps.timeout) {\n      this._operationTimeout = timeoutOps.timeout;\n    }\n    if (timeoutOps.cb) {\n      this._operationTimeoutCb = timeoutOps.cb;\n    }\n  }\n\n  var self = this;\n  if (this._operationTimeoutCb) {\n    this._timeout = setTimeout(function() {\n      self._operationTimeoutCb();\n    }, self._operationTimeout);\n  }\n\n  this._operationStart = new Date().getTime();\n\n  this._fn(this._attempts);\n};\n\nRetryOperation.prototype.try = function(fn) {\n  console.log('Using RetryOperation.try() is deprecated');\n  this.attempt(fn);\n};\n\nRetryOperation.prototype.start = function(fn) {\n  console.log('Using RetryOperation.start() is deprecated');\n  this.attempt(fn);\n};\n\nRetryOperation.prototype.start = RetryOperation.prototype.try;\n\nRetryOperation.prototype.errors = function() {\n  return this._errors;\n};\n\nRetryOperation.prototype.attempts = function() {\n  return this._attempts;\n};\n\nRetryOperation.prototype.mainError = function() {\n  if (this._errors.length === 0) {\n    return null;\n  }\n\n  var counts = {};\n  var mainError = null;\n  var mainErrorCount = 0;\n\n  for (var i = 0; i < this._errors.length; i++) {\n    var error = this._errors[i];\n    var message = error.message;\n    var count = (counts[message] || 0) + 1;\n\n    counts[message] = count;\n\n    if (count >= mainErrorCount) {\n      mainError = error;\n      mainErrorCount = count;\n    }\n  }\n\n  return mainError;\n};\n","var RetryOperation = require('./retry_operation');\n\nexports.operation = function(options) {\n  var timeouts = exports.timeouts(options);\n  return new RetryOperation(timeouts, {\n      forever: options && (options.forever || options.retries === Infinity),\n      unref: options && options.unref,\n      maxRetryTime: options && options.maxRetryTime\n  });\n};\n\nexports.timeouts = function(options) {\n  if (options instanceof Array) {\n    return [].concat(options);\n  }\n\n  var opts = {\n    retries: 10,\n    factor: 2,\n    minTimeout: 1 * 1000,\n    maxTimeout: Infinity,\n    randomize: false\n  };\n  for (var key in options) {\n    opts[key] = options[key];\n  }\n\n  if (opts.minTimeout > opts.maxTimeout) {\n    throw new Error('minTimeout is greater than maxTimeout');\n  }\n\n  var timeouts = [];\n  for (var i = 0; i < opts.retries; i++) {\n    timeouts.push(this.createTimeout(i, opts));\n  }\n\n  if (options && options.forever && !timeouts.length) {\n    timeouts.push(this.createTimeout(i, opts));\n  }\n\n  // sort the array numerically ascending\n  timeouts.sort(function(a,b) {\n    return a - b;\n  });\n\n  return timeouts;\n};\n\nexports.createTimeout = function(attempt, opts) {\n  var random = (opts.randomize)\n    ? (Math.random() + 1)\n    : 1;\n\n  var timeout = Math.round(random * Math.max(opts.minTimeout, 1) * Math.pow(opts.factor, attempt));\n  timeout = Math.min(timeout, opts.maxTimeout);\n\n  return timeout;\n};\n\nexports.wrap = function(obj, options, methods) {\n  if (options instanceof Array) {\n    methods = options;\n    options = null;\n  }\n\n  if (!methods) {\n    methods = [];\n    for (var key in obj) {\n      if (typeof obj[key] === 'function') {\n        methods.push(key);\n      }\n    }\n  }\n\n  for (var i = 0; i < methods.length; i++) {\n    var method   = methods[i];\n    var original = obj[method];\n\n    obj[method] = function retryWrapper(original) {\n      var op       = exports.operation(options);\n      var args     = Array.prototype.slice.call(arguments, 1);\n      var callback = args.pop();\n\n      args.push(function(err) {\n        if (op.retry(err)) {\n          return;\n        }\n        if (err) {\n          arguments[0] = op.mainError();\n        }\n        callback.apply(this, arguments);\n      });\n\n      op.attempt(function() {\n        original.apply(obj, args);\n      });\n    }.bind(obj, original);\n    obj[method].options = options;\n  }\n};\n","module.exports = require('./lib/retry');","// Packages\nvar retrier = require('retry');\n\nfunction retry(fn, opts) {\n  function run(resolve, reject) {\n    var options = opts || {};\n    var op;\n\n    // Default `randomize` to true\n    if (!('randomize' in options)) {\n      options.randomize = true;\n    }\n\n    op = retrier.operation(options);\n\n    // We allow the user to abort retrying\n    // this makes sense in the cases where\n    // knowledge is obtained that retrying\n    // would be futile (e.g.: auth errors)\n\n    function bail(err) {\n      reject(err || new Error('Aborted'));\n    }\n\n    function onError(err, num) {\n      if (err.bail) {\n        bail(err);\n        return;\n      }\n\n      if (!op.retry(err)) {\n        reject(op.mainError());\n      } else if (options.onRetry) {\n        options.onRetry(err, num);\n      }\n    }\n\n    function runAttempt(num) {\n      var val;\n\n      try {\n        val = fn(bail, num);\n      } catch (err) {\n        onError(err, num);\n        return;\n      }\n\n      Promise.resolve(val)\n        .then(resolve)\n        .catch(function catchIt(err) {\n          onError(err, num);\n        });\n    }\n\n    op.attempt(runAttempt);\n  }\n\n  return new Promise(run);\n}\n\nmodule.exports = retry;\n","// this file gets copied to the dist folder\n// it makes undici work in the browser by reusing the global fetch\n// it's the simplest way I've found to make http requests work in Node.js, Serverles Functions, Edge Functions, and the browser\n// this should work as long as this module is used via Next.js/Webpack\n// moving forward we will have to solve this problem in a more robust way\n// reusing https://github.com/inrupt/universal-fetch\n// or seeing how/if cross-fetch solves https://github.com/lquixada/cross-fetch/issues/69\nexport const fetch = globalThis.fetch.bind(globalThis);\n","function throttle(function_, wait) {\n\tif (typeof function_ !== 'function') {\n\t\tthrow new TypeError(`Expected the first argument to be a \\`function\\`, got \\`${typeof function_}\\`.`);\n\t}\n\n\t// TODO: Add `wait` validation too in the next major version.\n\n\tlet timeoutId;\n\tlet lastCallTime = 0;\n\n\treturn function throttled(...arguments_) { // eslint-disable-line func-names\n\t\tclearTimeout(timeoutId);\n\n\t\tconst now = Date.now();\n\t\tconst timeSinceLastCall = now - lastCallTime;\n\t\tconst delayForNextCall = wait - timeSinceLastCall;\n\n\t\tif (delayForNextCall <= 0) {\n\t\t\tlastCallTime = now;\n\t\t\tfunction_.apply(this, arguments_);\n\t\t} else {\n\t\t\ttimeoutId = setTimeout(() => {\n\t\t\t\tlastCallTime = Date.now();\n\t\t\t\tfunction_.apply(this, arguments_);\n\t\t\t}, delayForNextCall);\n\t\t}\n\t};\n}\n\nmodule.exports = throttle;\n","// src/helpers.ts\nimport { isNodeProcess } from \"is-node-process\";\n\n// src/multipart/helpers.ts\nimport { Readable } from \"stream\";\nimport isBuffer from \"is-buffer\";\nvar supportsNewBlobFromArrayBuffer = new Promise((resolve) => {\n  try {\n    const helloAsArrayBuffer = new Uint8Array([104, 101, 108, 108, 111]);\n    const blob = new Blob([helloAsArrayBuffer]);\n    blob.text().then((text) => {\n      resolve(text === \"hello\");\n    }).catch(() => {\n      resolve(false);\n    });\n  } catch {\n    resolve(false);\n  }\n});\nasync function toReadableStream(value) {\n  if (value instanceof ReadableStream) {\n    return value;\n  }\n  if (value instanceof Blob) {\n    return value.stream();\n  }\n  if (isNodeJsReadableStream(value)) {\n    return Readable.toWeb(value);\n  }\n  let streamValue;\n  if (value instanceof ArrayBuffer) {\n    streamValue = new Uint8Array(value);\n  } else if (isNodeJsBuffer(value)) {\n    streamValue = value;\n  } else {\n    streamValue = stringToUint8Array(value);\n  }\n  if (await supportsNewBlobFromArrayBuffer) {\n    return new Blob([streamValue]).stream();\n  }\n  return new ReadableStream({\n    start(controller) {\n      controller.enqueue(streamValue);\n      controller.close();\n    }\n  });\n}\nfunction isNodeJsReadableStream(value) {\n  return typeof value === \"object\" && typeof value.pipe === \"function\" && value.readable && typeof value._read === \"function\" && // @ts-expect-error _readableState does exists on Readable\n  typeof value._readableState === \"object\";\n}\nfunction stringToUint8Array(s) {\n  const enc = new TextEncoder();\n  return enc.encode(s);\n}\nfunction isNodeJsBuffer(value) {\n  return isBuffer(value);\n}\n\n// src/bytes.ts\nvar parseRegExp = /^((-|\\+)?(\\d+(?:\\.\\d+)?)) *(kb|mb|gb|tb|pb)$/i;\nvar map = {\n  b: 1,\n  // eslint-disable-next-line no-bitwise -- fine\n  kb: 1 << 10,\n  // eslint-disable-next-line no-bitwise -- fine\n  mb: 1 << 20,\n  // eslint-disable-next-line no-bitwise -- fine\n  gb: 1 << 30,\n  tb: Math.pow(1024, 4),\n  pb: Math.pow(1024, 5)\n};\nfunction bytes(val) {\n  if (typeof val === \"number\" && !isNaN(val)) {\n    return val;\n  }\n  if (typeof val !== \"string\") {\n    return null;\n  }\n  const results = parseRegExp.exec(val);\n  let floatValue;\n  let unit = \"b\";\n  if (!results) {\n    floatValue = parseInt(val, 10);\n  } else {\n    const [, res, , , unitMatch] = results;\n    if (!res) {\n      return null;\n    }\n    floatValue = parseFloat(res);\n    if (unitMatch) {\n      unit = unitMatch.toLowerCase();\n    }\n  }\n  if (isNaN(floatValue)) {\n    return null;\n  }\n  return Math.floor(map[unit] * floatValue);\n}\n\n// src/helpers.ts\nvar defaultVercelBlobApiUrl = \"https://vercel.com/api/blob\";\nfunction getTokenFromOptionsOrEnv(options) {\n  if (options == null ? void 0 : options.token) {\n    return options.token;\n  }\n  if (process.env.BLOB_READ_WRITE_TOKEN) {\n    return process.env.BLOB_READ_WRITE_TOKEN;\n  }\n  throw new BlobError(\n    \"No token found. Either configure the `BLOB_READ_WRITE_TOKEN` environment variable, or pass a `token` option to your calls.\"\n  );\n}\nvar BlobError = class extends Error {\n  constructor(message) {\n    super(`Vercel Blob: ${message}`);\n  }\n};\nfunction getDownloadUrl(blobUrl) {\n  const url = new URL(blobUrl);\n  url.searchParams.set(\"download\", \"1\");\n  return url.toString();\n}\nfunction isPlainObject(value) {\n  if (typeof value !== \"object\" || value === null) {\n    return false;\n  }\n  const prototype = Object.getPrototypeOf(value);\n  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);\n}\nvar disallowedPathnameCharacters = [\"//\"];\nvar supportsRequestStreams = (() => {\n  if (isNodeProcess()) {\n    return true;\n  }\n  const apiUrl = getApiUrl();\n  if (apiUrl.startsWith(\"http://localhost\")) {\n    return false;\n  }\n  let duplexAccessed = false;\n  const hasContentType = new Request(getApiUrl(), {\n    body: new ReadableStream(),\n    method: \"POST\",\n    // @ts-expect-error -- TypeScript doesn't yet have duplex but it's in the spec: https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1729\n    get duplex() {\n      duplexAccessed = true;\n      return \"half\";\n    }\n  }).headers.has(\"Content-Type\");\n  return duplexAccessed && !hasContentType;\n})();\nfunction getApiUrl(pathname = \"\") {\n  let baseUrl = null;\n  try {\n    baseUrl = process.env.VERCEL_BLOB_API_URL || process.env.NEXT_PUBLIC_VERCEL_BLOB_API_URL;\n  } catch {\n  }\n  return `${baseUrl || defaultVercelBlobApiUrl}${pathname}`;\n}\nvar TEXT_ENCODER = typeof TextEncoder === \"function\" ? new TextEncoder() : null;\nfunction computeBodyLength(body) {\n  if (!body) {\n    return 0;\n  }\n  if (typeof body === \"string\") {\n    if (TEXT_ENCODER) {\n      return TEXT_ENCODER.encode(body).byteLength;\n    }\n    return new Blob([body]).size;\n  }\n  if (\"byteLength\" in body && typeof body.byteLength === \"number\") {\n    return body.byteLength;\n  }\n  if (\"size\" in body && typeof body.size === \"number\") {\n    return body.size;\n  }\n  return 0;\n}\nvar createChunkTransformStream = (chunkSize, onProgress) => {\n  let buffer = new Uint8Array(0);\n  return new TransformStream({\n    transform(chunk, controller) {\n      queueMicrotask(() => {\n        const newBuffer = new Uint8Array(buffer.length + chunk.byteLength);\n        newBuffer.set(buffer);\n        newBuffer.set(new Uint8Array(chunk), buffer.length);\n        buffer = newBuffer;\n        while (buffer.length >= chunkSize) {\n          const newChunk = buffer.slice(0, chunkSize);\n          controller.enqueue(newChunk);\n          onProgress == null ? void 0 : onProgress(newChunk.byteLength);\n          buffer = buffer.slice(chunkSize);\n        }\n      });\n    },\n    flush(controller) {\n      queueMicrotask(() => {\n        if (buffer.length > 0) {\n          controller.enqueue(buffer);\n          onProgress == null ? void 0 : onProgress(buffer.byteLength);\n        }\n      });\n    }\n  });\n};\nfunction isReadableStream(value) {\n  return (\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition -- Not present in Node.js 16\n    globalThis.ReadableStream && // TODO: Can be removed once Node.js 16 is no more required internally\n    value instanceof ReadableStream\n  );\n}\nfunction isStream(value) {\n  if (isReadableStream(value)) {\n    return true;\n  }\n  if (isNodeJsReadableStream(value)) {\n    return true;\n  }\n  return false;\n}\n\n// src/api.ts\nimport retry from \"async-retry\";\n\n// src/is-network-error.ts\nvar objectToString = Object.prototype.toString;\nvar isError = (value) => objectToString.call(value) === \"[object Error]\";\nvar errorMessages = /* @__PURE__ */ new Set([\n  \"network error\",\n  // Chrome\n  \"Failed to fetch\",\n  // Chrome\n  \"NetworkError when attempting to fetch resource.\",\n  // Firefox\n  \"The Internet connection appears to be offline.\",\n  // Safari 16\n  \"Load failed\",\n  // Safari 17+\n  \"Network request failed\",\n  // `cross-fetch`\n  \"fetch failed\",\n  // Undici (Node.js)\n  \"terminated\"\n  // Undici (Node.js)\n]);\nfunction isNetworkError(error) {\n  const isValid = error && isError(error) && error.name === \"TypeError\" && typeof error.message === \"string\";\n  if (!isValid) {\n    return false;\n  }\n  if (error.message === \"Load failed\") {\n    return error.stack === void 0;\n  }\n  return errorMessages.has(error.message);\n}\n\n// src/debug.ts\nvar debugIsActive = false;\nvar _a, _b;\ntry {\n  if (((_a = process.env.DEBUG) == null ? void 0 : _a.includes(\"blob\")) || ((_b = process.env.NEXT_PUBLIC_DEBUG) == null ? void 0 : _b.includes(\"blob\"))) {\n    debugIsActive = true;\n  }\n} catch (error) {\n}\nfunction debug(message, ...args) {\n  if (debugIsActive) {\n    console.debug(`vercel-blob: ${message}`, ...args);\n  }\n}\n\n// src/fetch.ts\nimport { fetch } from \"undici\";\nvar hasFetch = typeof fetch === \"function\";\nvar hasFetchWithUploadProgress = hasFetch && supportsRequestStreams;\nvar CHUNK_SIZE = 64 * 1024;\nvar blobFetch = async ({\n  input,\n  init,\n  onUploadProgress\n}) => {\n  debug(\"using fetch\");\n  let body;\n  if (init.body) {\n    if (onUploadProgress) {\n      const stream = await toReadableStream(init.body);\n      let loaded = 0;\n      const chunkTransformStream = createChunkTransformStream(\n        CHUNK_SIZE,\n        (newLoaded) => {\n          loaded += newLoaded;\n          onUploadProgress(loaded);\n        }\n      );\n      body = stream.pipeThrough(chunkTransformStream);\n    } else {\n      body = init.body;\n    }\n  }\n  const duplex = supportsRequestStreams && body && isStream(body) ? \"half\" : void 0;\n  return fetch(\n    input,\n    // @ts-expect-error -- Blob and Nodejs Blob are triggering type errors, fine with it\n    {\n      ...init,\n      ...init.body ? { body } : {},\n      duplex\n    }\n  );\n};\n\n// src/xhr.ts\nvar hasXhr = typeof XMLHttpRequest !== \"undefined\";\nvar blobXhr = async ({\n  input,\n  init,\n  onUploadProgress\n}) => {\n  debug(\"using xhr\");\n  let body = null;\n  if (init.body) {\n    if (isReadableStream(init.body)) {\n      body = await new Response(init.body).blob();\n    } else {\n      body = init.body;\n    }\n  }\n  return new Promise((resolve, reject) => {\n    const xhr = new XMLHttpRequest();\n    xhr.open(init.method || \"GET\", input.toString(), true);\n    if (onUploadProgress) {\n      xhr.upload.addEventListener(\"progress\", (event) => {\n        if (event.lengthComputable) {\n          onUploadProgress(event.loaded);\n        }\n      });\n    }\n    xhr.onload = () => {\n      var _a3;\n      if ((_a3 = init.signal) == null ? void 0 : _a3.aborted) {\n        reject(new DOMException(\"The user aborted the request.\", \"AbortError\"));\n        return;\n      }\n      const headers = new Headers();\n      const rawHeaders = xhr.getAllResponseHeaders().trim().split(/[\\r\\n]+/);\n      rawHeaders.forEach((line) => {\n        const parts = line.split(\": \");\n        const key = parts.shift();\n        const value = parts.join(\": \");\n        if (key) headers.set(key.toLowerCase(), value);\n      });\n      const response = new Response(xhr.response, {\n        status: xhr.status,\n        statusText: xhr.statusText,\n        headers\n      });\n      resolve(response);\n    };\n    xhr.onerror = () => {\n      reject(new TypeError(\"Network request failed\"));\n    };\n    xhr.ontimeout = () => {\n      reject(new TypeError(\"Network request timed out\"));\n    };\n    xhr.onabort = () => {\n      reject(new DOMException(\"The user aborted a request.\", \"AbortError\"));\n    };\n    if (init.headers) {\n      const headers = new Headers(init.headers);\n      headers.forEach((value, key) => {\n        xhr.setRequestHeader(key, value);\n      });\n    }\n    if (init.signal) {\n      init.signal.addEventListener(\"abort\", () => {\n        xhr.abort();\n      });\n      if (init.signal.aborted) {\n        xhr.abort();\n        return;\n      }\n    }\n    xhr.send(body);\n  });\n};\n\n// src/request.ts\nvar blobRequest = async ({\n  input,\n  init,\n  onUploadProgress\n}) => {\n  if (onUploadProgress) {\n    if (hasFetchWithUploadProgress) {\n      return blobFetch({ input, init, onUploadProgress });\n    }\n    if (hasXhr) {\n      return blobXhr({ input, init, onUploadProgress });\n    }\n  }\n  if (hasFetch) {\n    return blobFetch({ input, init });\n  }\n  if (hasXhr) {\n    return blobXhr({ input, init });\n  }\n  throw new Error(\"No request implementation available\");\n};\n\n// src/dom-exception.ts\nvar _a2;\nvar DOMException2 = (_a2 = globalThis.DOMException) != null ? _a2 : (() => {\n  try {\n    atob(\"~\");\n  } catch (err) {\n    return Object.getPrototypeOf(err).constructor;\n  }\n})();\n\n// src/api.ts\nvar MAXIMUM_PATHNAME_LENGTH = 950;\nvar BlobAccessError = class extends BlobError {\n  constructor() {\n    super(\"Access denied, please provide a valid token for this resource.\");\n  }\n};\nvar BlobContentTypeNotAllowedError = class extends BlobError {\n  constructor(message) {\n    super(`Content type mismatch, ${message}.`);\n  }\n};\nvar BlobPathnameMismatchError = class extends BlobError {\n  constructor(message) {\n    super(\n      `Pathname mismatch, ${message}. Check the pathname used in upload() or put() matches the one from the client token.`\n    );\n  }\n};\nvar BlobClientTokenExpiredError = class extends BlobError {\n  constructor() {\n    super(\"Client token has expired.\");\n  }\n};\nvar BlobFileTooLargeError = class extends BlobError {\n  constructor(message) {\n    super(`File is too large, ${message}.`);\n  }\n};\nvar BlobStoreNotFoundError = class extends BlobError {\n  constructor() {\n    super(\"This store does not exist.\");\n  }\n};\nvar BlobStoreSuspendedError = class extends BlobError {\n  constructor() {\n    super(\"This store has been suspended.\");\n  }\n};\nvar BlobUnknownError = class extends BlobError {\n  constructor() {\n    super(\"Unknown error, please visit https://vercel.com/help.\");\n  }\n};\nvar BlobNotFoundError = class extends BlobError {\n  constructor() {\n    super(\"The requested blob does not exist\");\n  }\n};\nvar BlobServiceNotAvailable = class extends BlobError {\n  constructor() {\n    super(\"The blob service is currently not available. Please try again.\");\n  }\n};\nvar BlobServiceRateLimited = class extends BlobError {\n  constructor(seconds) {\n    super(\n      `Too many requests please lower the number of concurrent requests ${seconds ? ` - try again in ${seconds} seconds` : \"\"}.`\n    );\n    this.retryAfter = seconds != null ? seconds : 0;\n  }\n};\nvar BlobRequestAbortedError = class extends BlobError {\n  constructor() {\n    super(\"The request was aborted.\");\n  }\n};\nvar BLOB_API_VERSION = 11;\nfunction getApiVersion() {\n  let versionOverride = null;\n  try {\n    versionOverride = process.env.VERCEL_BLOB_API_VERSION_OVERRIDE || process.env.NEXT_PUBLIC_VERCEL_BLOB_API_VERSION_OVERRIDE;\n  } catch {\n  }\n  return `${versionOverride != null ? versionOverride : BLOB_API_VERSION}`;\n}\nfunction getRetries() {\n  try {\n    const retries = process.env.VERCEL_BLOB_RETRIES || \"10\";\n    return parseInt(retries, 10);\n  } catch {\n    return 10;\n  }\n}\nfunction createBlobServiceRateLimited(response) {\n  const retryAfter = response.headers.get(\"retry-after\");\n  return new BlobServiceRateLimited(\n    retryAfter ? parseInt(retryAfter, 10) : void 0\n  );\n}\nasync function getBlobError(response) {\n  var _a3, _b2, _c;\n  let code;\n  let message;\n  try {\n    const data = await response.json();\n    code = (_b2 = (_a3 = data.error) == null ? void 0 : _a3.code) != null ? _b2 : \"unknown_error\";\n    message = (_c = data.error) == null ? void 0 : _c.message;\n  } catch {\n    code = \"unknown_error\";\n  }\n  if ((message == null ? void 0 : message.includes(\"contentType\")) && message.includes(\"is not allowed\")) {\n    code = \"content_type_not_allowed\";\n  }\n  if ((message == null ? void 0 : message.includes('\"pathname\"')) && message.includes(\"does not match the token payload\")) {\n    code = \"client_token_pathname_mismatch\";\n  }\n  if (message === \"Token expired\") {\n    code = \"client_token_expired\";\n  }\n  if (message == null ? void 0 : message.includes(\"the file length cannot be greater than\")) {\n    code = \"file_too_large\";\n  }\n  let error;\n  switch (code) {\n    case \"store_suspended\":\n      error = new BlobStoreSuspendedError();\n      break;\n    case \"forbidden\":\n      error = new BlobAccessError();\n      break;\n    case \"content_type_not_allowed\":\n      error = new BlobContentTypeNotAllowedError(message);\n      break;\n    case \"client_token_pathname_mismatch\":\n      error = new BlobPathnameMismatchError(message);\n      break;\n    case \"client_token_expired\":\n      error = new BlobClientTokenExpiredError();\n      break;\n    case \"file_too_large\":\n      error = new BlobFileTooLargeError(message);\n      break;\n    case \"not_found\":\n      error = new BlobNotFoundError();\n      break;\n    case \"store_not_found\":\n      error = new BlobStoreNotFoundError();\n      break;\n    case \"bad_request\":\n      error = new BlobError(message != null ? message : \"Bad request\");\n      break;\n    case \"service_unavailable\":\n      error = new BlobServiceNotAvailable();\n      break;\n    case \"rate_limited\":\n      error = createBlobServiceRateLimited(response);\n      break;\n    case \"unknown_error\":\n    case \"not_allowed\":\n    default:\n      error = new BlobUnknownError();\n      break;\n  }\n  return { code, error };\n}\nasync function requestApi(pathname, init, commandOptions) {\n  const apiVersion = getApiVersion();\n  const token = getTokenFromOptionsOrEnv(commandOptions);\n  const extraHeaders = getProxyThroughAlternativeApiHeaderFromEnv();\n  const [, , , storeId = \"\"] = token.split(\"_\");\n  const requestId = `${storeId}:${Date.now()}:${Math.random().toString(16).slice(2)}`;\n  let retryCount = 0;\n  let bodyLength = 0;\n  let totalLoaded = 0;\n  const sendBodyLength = (commandOptions == null ? void 0 : commandOptions.onUploadProgress) || shouldUseXContentLength();\n  if (init.body && // 1. For upload progress we always need to know the total size of the body\n  // 2. In development we need the header for put() to work correctly when passing a stream\n  sendBodyLength) {\n    bodyLength = computeBodyLength(init.body);\n  }\n  if (commandOptions == null ? void 0 : commandOptions.onUploadProgress) {\n    commandOptions.onUploadProgress({\n      loaded: 0,\n      total: bodyLength,\n      percentage: 0\n    });\n  }\n  const apiResponse = await retry(\n    async (bail) => {\n      let res;\n      try {\n        res = await blobRequest({\n          input: getApiUrl(pathname),\n          init: {\n            ...init,\n            headers: {\n              \"x-api-blob-request-id\": requestId,\n              \"x-api-blob-request-attempt\": String(retryCount),\n              \"x-api-version\": apiVersion,\n              ...sendBodyLength ? { \"x-content-length\": String(bodyLength) } : {},\n              authorization: `Bearer ${token}`,\n              ...extraHeaders,\n              ...init.headers\n            }\n          },\n          onUploadProgress: (commandOptions == null ? void 0 : commandOptions.onUploadProgress) ? (loaded) => {\n            var _a3;\n            const total = bodyLength !== 0 ? bodyLength : loaded;\n            totalLoaded = loaded;\n            const percentage = bodyLength > 0 ? Number((loaded / total * 100).toFixed(2)) : 0;\n            if (percentage === 100 && bodyLength > 0) {\n              return;\n            }\n            (_a3 = commandOptions.onUploadProgress) == null ? void 0 : _a3.call(commandOptions, {\n              loaded,\n              // When passing a stream to put(), we have no way to know the total size of the body.\n              // Instead of defining total as total?: number we decided to set the total to the currently\n              // loaded number. This is not inaccurate and way more practical for DX.\n              // Passing down a stream to put() is very rare\n              total,\n              percentage\n            });\n          } : void 0\n        });\n      } catch (error2) {\n        if (error2 instanceof DOMException2 && error2.name === \"AbortError\") {\n          bail(new BlobRequestAbortedError());\n          return;\n        }\n        if (isNetworkError(error2)) {\n          throw error2;\n        }\n        if (error2 instanceof TypeError) {\n          bail(error2);\n          return;\n        }\n        throw error2;\n      }\n      if (res.ok) {\n        return res;\n      }\n      const { code, error } = await getBlobError(res);\n      if (code === \"unknown_error\" || code === \"service_unavailable\" || code === \"internal_server_error\") {\n        throw error;\n      }\n      bail(error);\n    },\n    {\n      retries: getRetries(),\n      onRetry: (error) => {\n        if (error instanceof Error) {\n          debug(`retrying API request to ${pathname}`, error.message);\n        }\n        retryCount = retryCount + 1;\n      }\n    }\n  );\n  if (!apiResponse) {\n    throw new BlobUnknownError();\n  }\n  if (commandOptions == null ? void 0 : commandOptions.onUploadProgress) {\n    commandOptions.onUploadProgress({\n      loaded: totalLoaded,\n      total: totalLoaded,\n      percentage: 100\n    });\n  }\n  return await apiResponse.json();\n}\nfunction getProxyThroughAlternativeApiHeaderFromEnv() {\n  const extraHeaders = {};\n  try {\n    if (\"VERCEL_BLOB_PROXY_THROUGH_ALTERNATIVE_API\" in process.env && process.env.VERCEL_BLOB_PROXY_THROUGH_ALTERNATIVE_API !== void 0) {\n      extraHeaders[\"x-proxy-through-alternative-api\"] = process.env.VERCEL_BLOB_PROXY_THROUGH_ALTERNATIVE_API;\n    } else if (\"NEXT_PUBLIC_VERCEL_BLOB_PROXY_THROUGH_ALTERNATIVE_API\" in process.env && process.env.NEXT_PUBLIC_VERCEL_BLOB_PROXY_THROUGH_ALTERNATIVE_API !== void 0) {\n      extraHeaders[\"x-proxy-through-alternative-api\"] = process.env.NEXT_PUBLIC_VERCEL_BLOB_PROXY_THROUGH_ALTERNATIVE_API;\n    }\n  } catch {\n  }\n  return extraHeaders;\n}\nfunction shouldUseXContentLength() {\n  try {\n    return process.env.VERCEL_BLOB_USE_X_CONTENT_LENGTH === \"1\";\n  } catch {\n    return false;\n  }\n}\n\n// src/put-helpers.ts\nvar putOptionHeaderMap = {\n  cacheControlMaxAge: \"x-cache-control-max-age\",\n  addRandomSuffix: \"x-add-random-suffix\",\n  allowOverwrite: \"x-allow-overwrite\",\n  contentType: \"x-content-type\"\n};\nfunction createPutHeaders(allowedOptions, options) {\n  const headers = {};\n  if (allowedOptions.includes(\"contentType\") && options.contentType) {\n    headers[putOptionHeaderMap.contentType] = options.contentType;\n  }\n  if (allowedOptions.includes(\"addRandomSuffix\") && options.addRandomSuffix !== void 0) {\n    headers[putOptionHeaderMap.addRandomSuffix] = options.addRandomSuffix ? \"1\" : \"0\";\n  }\n  if (allowedOptions.includes(\"allowOverwrite\") && options.allowOverwrite !== void 0) {\n    headers[putOptionHeaderMap.allowOverwrite] = options.allowOverwrite ? \"1\" : \"0\";\n  }\n  if (allowedOptions.includes(\"cacheControlMaxAge\") && options.cacheControlMaxAge !== void 0) {\n    headers[putOptionHeaderMap.cacheControlMaxAge] = options.cacheControlMaxAge.toString();\n  }\n  return headers;\n}\nasync function createPutOptions({\n  pathname,\n  options,\n  extraChecks,\n  getToken\n}) {\n  if (!pathname) {\n    throw new BlobError(\"pathname is required\");\n  }\n  if (pathname.length > MAXIMUM_PATHNAME_LENGTH) {\n    throw new BlobError(\n      `pathname is too long, maximum length is ${MAXIMUM_PATHNAME_LENGTH}`\n    );\n  }\n  for (const invalidCharacter of disallowedPathnameCharacters) {\n    if (pathname.includes(invalidCharacter)) {\n      throw new BlobError(\n        `pathname cannot contain \"${invalidCharacter}\", please encode it if needed`\n      );\n    }\n  }\n  if (!options) {\n    throw new BlobError(\"missing options, see usage\");\n  }\n  if (options.access !== \"public\") {\n    throw new BlobError('access must be \"public\"');\n  }\n  if (extraChecks) {\n    extraChecks(options);\n  }\n  if (getToken) {\n    options.token = await getToken(pathname, options);\n  }\n  return options;\n}\n\n// src/multipart/complete.ts\nfunction createCompleteMultipartUploadMethod({ allowedOptions, getToken, extraChecks }) {\n  return async (pathname, parts, optionsInput) => {\n    const options = await createPutOptions({\n      pathname,\n      options: optionsInput,\n      extraChecks,\n      getToken\n    });\n    const headers = createPutHeaders(allowedOptions, options);\n    return completeMultipartUpload({\n      uploadId: options.uploadId,\n      key: options.key,\n      pathname,\n      headers,\n      options,\n      parts\n    });\n  };\n}\nasync function completeMultipartUpload({\n  uploadId,\n  key,\n  pathname,\n  parts,\n  headers,\n  options\n}) {\n  const params = new URLSearchParams({ pathname });\n  try {\n    const response = await requestApi(\n      `/mpu?${params.toString()}`,\n      {\n        method: \"POST\",\n        headers: {\n          ...headers,\n          \"content-type\": \"application/json\",\n          \"x-mpu-action\": \"complete\",\n          \"x-mpu-upload-id\": uploadId,\n          // key can be any utf8 character so we need to encode it as HTTP headers can only be us-ascii\n          // https://www.rfc-editor.org/rfc/rfc7230#swection-3.2.4\n          \"x-mpu-key\": encodeURIComponent(key)\n        },\n        body: JSON.stringify(parts),\n        signal: options.abortSignal\n      },\n      options\n    );\n    debug(\"mpu: complete\", response);\n    return response;\n  } catch (error) {\n    if (error instanceof TypeError && (error.message === \"Failed to fetch\" || error.message === \"fetch failed\")) {\n      throw new BlobServiceNotAvailable();\n    } else {\n      throw error;\n    }\n  }\n}\n\n// src/multipart/create.ts\nfunction createCreateMultipartUploadMethod({ allowedOptions, getToken, extraChecks }) {\n  return async (pathname, optionsInput) => {\n    const options = await createPutOptions({\n      pathname,\n      options: optionsInput,\n      extraChecks,\n      getToken\n    });\n    const headers = createPutHeaders(allowedOptions, options);\n    const createMultipartUploadResponse = await createMultipartUpload(\n      pathname,\n      headers,\n      options\n    );\n    return {\n      key: createMultipartUploadResponse.key,\n      uploadId: createMultipartUploadResponse.uploadId\n    };\n  };\n}\nasync function createMultipartUpload(pathname, headers, options) {\n  debug(\"mpu: create\", \"pathname:\", pathname);\n  const params = new URLSearchParams({ pathname });\n  try {\n    const response = await requestApi(\n      `/mpu?${params.toString()}`,\n      {\n        method: \"POST\",\n        headers: {\n          ...headers,\n          \"x-mpu-action\": \"create\"\n        },\n        signal: options.abortSignal\n      },\n      options\n    );\n    debug(\"mpu: create\", response);\n    return response;\n  } catch (error) {\n    if (error instanceof TypeError && (error.message === \"Failed to fetch\" || error.message === \"fetch failed\")) {\n      throw new BlobServiceNotAvailable();\n    }\n    throw error;\n  }\n}\n\n// src/multipart/upload.ts\nimport throttle from \"throttleit\";\nfunction createUploadPartMethod({ allowedOptions, getToken, extraChecks }) {\n  return async (pathname, body, optionsInput) => {\n    const options = await createPutOptions({\n      pathname,\n      options: optionsInput,\n      extraChecks,\n      getToken\n    });\n    const headers = createPutHeaders(allowedOptions, options);\n    if (isPlainObject(body)) {\n      throw new BlobError(\n        \"Body must be a string, buffer or stream. You sent a plain JavaScript object, double check what you're trying to upload.\"\n      );\n    }\n    const result = await uploadPart({\n      uploadId: options.uploadId,\n      key: options.key,\n      pathname,\n      part: { blob: body, partNumber: options.partNumber },\n      headers,\n      options\n    });\n    return {\n      etag: result.etag,\n      partNumber: options.partNumber\n    };\n  };\n}\nasync function uploadPart({\n  uploadId,\n  key,\n  pathname,\n  headers,\n  options,\n  internalAbortController = new AbortController(),\n  part\n}) {\n  var _a3, _b2, _c;\n  const params = new URLSearchParams({ pathname });\n  const responsePromise = requestApi(\n    `/mpu?${params.toString()}`,\n    {\n      signal: internalAbortController.signal,\n      method: \"POST\",\n      headers: {\n        ...headers,\n        \"x-mpu-action\": \"upload\",\n        \"x-mpu-key\": encodeURIComponent(key),\n        \"x-mpu-upload-id\": uploadId,\n        \"x-mpu-part-number\": part.partNumber.toString()\n      },\n      // weird things between undici types and native fetch types\n      body: part.blob\n    },\n    options\n  );\n  function handleAbort() {\n    internalAbortController.abort();\n  }\n  if ((_a3 = options.abortSignal) == null ? void 0 : _a3.aborted) {\n    handleAbort();\n  } else {\n    (_b2 = options.abortSignal) == null ? void 0 : _b2.addEventListener(\"abort\", handleAbort);\n  }\n  const response = await responsePromise;\n  (_c = options.abortSignal) == null ? void 0 : _c.removeEventListener(\"abort\", handleAbort);\n  return response;\n}\nvar maxConcurrentUploads = typeof window !== \"undefined\" ? 6 : 8;\nvar partSizeInBytes = 8 * 1024 * 1024;\nvar maxBytesInMemory = maxConcurrentUploads * partSizeInBytes * 2;\nfunction uploadAllParts({\n  uploadId,\n  key,\n  pathname,\n  stream,\n  headers,\n  options,\n  totalToLoad\n}) {\n  debug(\"mpu: upload init\", \"key:\", key);\n  const internalAbortController = new AbortController();\n  return new Promise((resolve, reject) => {\n    const partsToUpload = [];\n    const completedParts = [];\n    const reader = stream.getReader();\n    let activeUploads = 0;\n    let reading = false;\n    let currentPartNumber = 1;\n    let rejected = false;\n    let currentBytesInMemory = 0;\n    let doneReading = false;\n    let bytesSent = 0;\n    let arrayBuffers = [];\n    let currentPartBytesRead = 0;\n    let onUploadProgress;\n    const totalLoadedPerPartNumber = {};\n    if (options.onUploadProgress) {\n      onUploadProgress = throttle(() => {\n        var _a3;\n        const loaded = Object.values(totalLoadedPerPartNumber).reduce(\n          (acc, cur) => {\n            return acc + cur;\n          },\n          0\n        );\n        const total = totalToLoad || loaded;\n        const percentage = totalToLoad > 0 ? Number(((loaded / totalToLoad || loaded) * 100).toFixed(2)) : 0;\n        (_a3 = options.onUploadProgress) == null ? void 0 : _a3.call(options, { loaded, total, percentage });\n      }, 150);\n    }\n    read().catch(cancel);\n    async function read() {\n      debug(\n        \"mpu: upload read start\",\n        \"activeUploads:\",\n        activeUploads,\n        \"currentBytesInMemory:\",\n        `${bytes(currentBytesInMemory)}/${bytes(maxBytesInMemory)}`,\n        \"bytesSent:\",\n        bytes(bytesSent)\n      );\n      reading = true;\n      while (currentBytesInMemory < maxBytesInMemory && !rejected) {\n        try {\n          const { value, done } = await reader.read();\n          if (done) {\n            doneReading = true;\n            debug(\"mpu: upload read consumed the whole stream\");\n            if (arrayBuffers.length > 0) {\n              partsToUpload.push({\n                partNumber: currentPartNumber++,\n                blob: new Blob(arrayBuffers, {\n                  type: \"application/octet-stream\"\n                })\n              });\n              sendParts();\n            }\n            reading = false;\n            return;\n          }\n          currentBytesInMemory += value.byteLength;\n          let valueOffset = 0;\n          while (valueOffset < value.byteLength) {\n            const remainingPartSize = partSizeInBytes - currentPartBytesRead;\n            const endOffset = Math.min(\n              valueOffset + remainingPartSize,\n              value.byteLength\n            );\n            const chunk = value.slice(valueOffset, endOffset);\n            arrayBuffers.push(chunk);\n            currentPartBytesRead += chunk.byteLength;\n            valueOffset = endOffset;\n            if (currentPartBytesRead === partSizeInBytes) {\n              partsToUpload.push({\n                partNumber: currentPartNumber++,\n                blob: new Blob(arrayBuffers, {\n                  type: \"application/octet-stream\"\n                })\n              });\n              arrayBuffers = [];\n              currentPartBytesRead = 0;\n              sendParts();\n            }\n          }\n        } catch (error) {\n          cancel(error);\n        }\n      }\n      debug(\n        \"mpu: upload read end\",\n        \"activeUploads:\",\n        activeUploads,\n        \"currentBytesInMemory:\",\n        `${bytes(currentBytesInMemory)}/${bytes(maxBytesInMemory)}`,\n        \"bytesSent:\",\n        bytes(bytesSent)\n      );\n      reading = false;\n    }\n    async function sendPart(part) {\n      activeUploads++;\n      debug(\n        \"mpu: upload send part start\",\n        \"partNumber:\",\n        part.partNumber,\n        \"size:\",\n        part.blob.size,\n        \"activeUploads:\",\n        activeUploads,\n        \"currentBytesInMemory:\",\n        `${bytes(currentBytesInMemory)}/${bytes(maxBytesInMemory)}`,\n        \"bytesSent:\",\n        bytes(bytesSent)\n      );\n      try {\n        const uploadProgressForPart = options.onUploadProgress ? (event) => {\n          totalLoadedPerPartNumber[part.partNumber] = event.loaded;\n          if (onUploadProgress) {\n            onUploadProgress();\n          }\n        } : void 0;\n        const completedPart = await uploadPart({\n          uploadId,\n          key,\n          pathname,\n          headers,\n          options: {\n            ...options,\n            onUploadProgress: uploadProgressForPart\n          },\n          internalAbortController,\n          part\n        });\n        debug(\n          \"mpu: upload send part end\",\n          \"partNumber:\",\n          part.partNumber,\n          \"activeUploads\",\n          activeUploads,\n          \"currentBytesInMemory:\",\n          `${bytes(currentBytesInMemory)}/${bytes(maxBytesInMemory)}`,\n          \"bytesSent:\",\n          bytes(bytesSent)\n        );\n        if (rejected) {\n          return;\n        }\n        completedParts.push({\n          partNumber: part.partNumber,\n          etag: completedPart.etag\n        });\n        currentBytesInMemory -= part.blob.size;\n        activeUploads--;\n        bytesSent += part.blob.size;\n        if (partsToUpload.length > 0) {\n          sendParts();\n        }\n        if (doneReading) {\n          if (activeUploads === 0) {\n            reader.releaseLock();\n            resolve(completedParts);\n          }\n          return;\n        }\n        if (!reading) {\n          read().catch(cancel);\n        }\n      } catch (error) {\n        cancel(error);\n      }\n    }\n    function sendParts() {\n      if (rejected) {\n        return;\n      }\n      debug(\n        \"send parts\",\n        \"activeUploads\",\n        activeUploads,\n        \"partsToUpload\",\n        partsToUpload.length\n      );\n      while (activeUploads < maxConcurrentUploads && partsToUpload.length > 0) {\n        const partToSend = partsToUpload.shift();\n        if (partToSend) {\n          void sendPart(partToSend);\n        }\n      }\n    }\n    function cancel(error) {\n      if (rejected) {\n        return;\n      }\n      rejected = true;\n      internalAbortController.abort();\n      reader.releaseLock();\n      if (error instanceof TypeError && (error.message === \"Failed to fetch\" || error.message === \"fetch failed\")) {\n        reject(new BlobServiceNotAvailable());\n      } else {\n        reject(error);\n      }\n    }\n  });\n}\n\n// src/put.ts\nimport throttle2 from \"throttleit\";\n\n// src/multipart/uncontrolled.ts\nasync function uncontrolledMultipartUpload(pathname, body, headers, options) {\n  debug(\"mpu: init\", \"pathname:\", pathname, \"headers:\", headers);\n  const optionsWithoutOnUploadProgress = {\n    ...options,\n    onUploadProgress: void 0\n  };\n  const createMultipartUploadResponse = await createMultipartUpload(\n    pathname,\n    headers,\n    optionsWithoutOnUploadProgress\n  );\n  const totalToLoad = computeBodyLength(body);\n  const stream = await toReadableStream(body);\n  const parts = await uploadAllParts({\n    uploadId: createMultipartUploadResponse.uploadId,\n    key: createMultipartUploadResponse.key,\n    pathname,\n    stream,\n    headers,\n    options,\n    totalToLoad\n  });\n  const blob = await completeMultipartUpload({\n    uploadId: createMultipartUploadResponse.uploadId,\n    key: createMultipartUploadResponse.key,\n    pathname,\n    parts,\n    headers,\n    options: optionsWithoutOnUploadProgress\n  });\n  return blob;\n}\n\n// src/put.ts\nfunction createPutMethod({\n  allowedOptions,\n  getToken,\n  extraChecks\n}) {\n  return async function put(pathname, body, optionsInput) {\n    if (!body) {\n      throw new BlobError(\"body is required\");\n    }\n    if (isPlainObject(body)) {\n      throw new BlobError(\n        \"Body must be a string, buffer or stream. You sent a plain JavaScript object, double check what you're trying to upload.\"\n      );\n    }\n    const options = await createPutOptions({\n      pathname,\n      options: optionsInput,\n      extraChecks,\n      getToken\n    });\n    const headers = createPutHeaders(allowedOptions, options);\n    if (options.multipart === true) {\n      return uncontrolledMultipartUpload(pathname, body, headers, options);\n    }\n    const onUploadProgress = options.onUploadProgress ? throttle2(options.onUploadProgress, 100) : void 0;\n    const params = new URLSearchParams({ pathname });\n    const response = await requestApi(\n      `/?${params.toString()}`,\n      {\n        method: \"PUT\",\n        body,\n        headers,\n        signal: options.abortSignal\n      },\n      {\n        ...options,\n        onUploadProgress\n      }\n    );\n    return {\n      url: response.url,\n      downloadUrl: response.downloadUrl,\n      pathname: response.pathname,\n      contentType: response.contentType,\n      contentDisposition: response.contentDisposition\n    };\n  };\n}\n\n// src/multipart/create-uploader.ts\nfunction createCreateMultipartUploaderMethod({ allowedOptions, getToken, extraChecks }) {\n  return async (pathname, optionsInput) => {\n    const options = await createPutOptions({\n      pathname,\n      options: optionsInput,\n      extraChecks,\n      getToken\n    });\n    const headers = createPutHeaders(allowedOptions, options);\n    const createMultipartUploadResponse = await createMultipartUpload(\n      pathname,\n      headers,\n      options\n    );\n    return {\n      key: createMultipartUploadResponse.key,\n      uploadId: createMultipartUploadResponse.uploadId,\n      async uploadPart(partNumber, body) {\n        if (isPlainObject(body)) {\n          throw new BlobError(\n            \"Body must be a string, buffer or stream. You sent a plain JavaScript object, double check what you're trying to upload.\"\n          );\n        }\n        const result = await uploadPart({\n          uploadId: createMultipartUploadResponse.uploadId,\n          key: createMultipartUploadResponse.key,\n          pathname,\n          part: { partNumber, blob: body },\n          headers,\n          options\n        });\n        return {\n          etag: result.etag,\n          partNumber\n        };\n      },\n      async complete(parts) {\n        return completeMultipartUpload({\n          uploadId: createMultipartUploadResponse.uploadId,\n          key: createMultipartUploadResponse.key,\n          pathname,\n          parts,\n          headers,\n          options\n        });\n      }\n    };\n  };\n}\n\n// src/create-folder.ts\nasync function createFolder(pathname, options = {}) {\n  const folderPathname = pathname.endsWith(\"/\") ? pathname : `${pathname}/`;\n  const headers = {};\n  headers[putOptionHeaderMap.addRandomSuffix] = \"0\";\n  const params = new URLSearchParams({ pathname: folderPathname });\n  const response = await requestApi(\n    `/?${params.toString()}`,\n    {\n      method: \"PUT\",\n      headers,\n      signal: options.abortSignal\n    },\n    options\n  );\n  return {\n    url: response.url,\n    pathname: response.pathname\n  };\n}\n\nexport {\n  getTokenFromOptionsOrEnv,\n  BlobError,\n  getDownloadUrl,\n  disallowedPathnameCharacters,\n  MAXIMUM_PATHNAME_LENGTH,\n  BlobAccessError,\n  BlobContentTypeNotAllowedError,\n  BlobPathnameMismatchError,\n  BlobClientTokenExpiredError,\n  BlobFileTooLargeError,\n  BlobStoreNotFoundError,\n  BlobStoreSuspendedError,\n  BlobUnknownError,\n  BlobNotFoundError,\n  BlobServiceNotAvailable,\n  BlobServiceRateLimited,\n  BlobRequestAbortedError,\n  requestApi,\n  createCompleteMultipartUploadMethod,\n  createCreateMultipartUploadMethod,\n  createUploadPartMethod,\n  createPutMethod,\n  createCreateMultipartUploaderMethod,\n  createFolder\n};\n/*!\n * bytes\n * Copyright(c) 2012-2014 TJ Holowaychuk\n * Copyright(c) 2015 Jed Watson\n * MIT Licensed\n */\n//# sourceMappingURL=chunk-Z56QURM6.js.map","import {\n  BlobAccessError,\n  BlobClientTokenExpiredError,\n  BlobContentTypeNotAllowedError,\n  BlobError,\n  BlobFileTooLargeError,\n  BlobNotFoundError,\n  BlobPathnameMismatchError,\n  BlobRequestAbortedError,\n  BlobServiceNotAvailable,\n  BlobServiceRateLimited,\n  BlobStoreNotFoundError,\n  BlobStoreSuspendedError,\n  BlobUnknownError,\n  MAXIMUM_PATHNAME_LENGTH,\n  createCompleteMultipartUploadMethod,\n  createCreateMultipartUploadMethod,\n  createCreateMultipartUploaderMethod,\n  createFolder,\n  createPutMethod,\n  createUploadPartMethod,\n  disallowedPathnameCharacters,\n  getDownloadUrl,\n  requestApi\n} from \"./chunk-Z56QURM6.js\";\n\n// src/del.ts\nasync function del(urlOrPathname, options) {\n  await requestApi(\n    \"/delete\",\n    {\n      method: \"POST\",\n      headers: { \"content-type\": \"application/json\" },\n      body: JSON.stringify({\n        urls: Array.isArray(urlOrPathname) ? urlOrPathname : [urlOrPathname]\n      }),\n      signal: options == null ? void 0 : options.abortSignal\n    },\n    options\n  );\n}\n\n// src/head.ts\nasync function head(urlOrPathname, options) {\n  const searchParams = new URLSearchParams({ url: urlOrPathname });\n  const response = await requestApi(\n    `?${searchParams.toString()}`,\n    // HEAD can't have body as a response, so we use GET\n    {\n      method: \"GET\",\n      signal: options == null ? void 0 : options.abortSignal\n    },\n    options\n  );\n  return {\n    url: response.url,\n    downloadUrl: response.downloadUrl,\n    pathname: response.pathname,\n    size: response.size,\n    contentType: response.contentType,\n    contentDisposition: response.contentDisposition,\n    cacheControl: response.cacheControl,\n    uploadedAt: new Date(response.uploadedAt)\n  };\n}\n\n// src/list.ts\nasync function list(options) {\n  var _a;\n  const searchParams = new URLSearchParams();\n  if (options == null ? void 0 : options.limit) {\n    searchParams.set(\"limit\", options.limit.toString());\n  }\n  if (options == null ? void 0 : options.prefix) {\n    searchParams.set(\"prefix\", options.prefix);\n  }\n  if (options == null ? void 0 : options.cursor) {\n    searchParams.set(\"cursor\", options.cursor);\n  }\n  if (options == null ? void 0 : options.mode) {\n    searchParams.set(\"mode\", options.mode);\n  }\n  const response = await requestApi(\n    `?${searchParams.toString()}`,\n    {\n      method: \"GET\",\n      signal: options == null ? void 0 : options.abortSignal\n    },\n    options\n  );\n  if ((options == null ? void 0 : options.mode) === \"folded\") {\n    return {\n      folders: (_a = response.folders) != null ? _a : [],\n      cursor: response.cursor,\n      hasMore: response.hasMore,\n      blobs: response.blobs.map(mapBlobResult)\n    };\n  }\n  return {\n    cursor: response.cursor,\n    hasMore: response.hasMore,\n    blobs: response.blobs.map(mapBlobResult)\n  };\n}\nfunction mapBlobResult(blobResult) {\n  return {\n    url: blobResult.url,\n    downloadUrl: blobResult.downloadUrl,\n    pathname: blobResult.pathname,\n    size: blobResult.size,\n    uploadedAt: new Date(blobResult.uploadedAt)\n  };\n}\n\n// src/copy.ts\nasync function copy(fromUrlOrPathname, toPathname, options) {\n  if (!options) {\n    throw new BlobError(\"missing options, see usage\");\n  }\n  if (options.access !== \"public\") {\n    throw new BlobError('access must be \"public\"');\n  }\n  if (toPathname.length > MAXIMUM_PATHNAME_LENGTH) {\n    throw new BlobError(\n      `pathname is too long, maximum length is ${MAXIMUM_PATHNAME_LENGTH}`\n    );\n  }\n  for (const invalidCharacter of disallowedPathnameCharacters) {\n    if (toPathname.includes(invalidCharacter)) {\n      throw new BlobError(\n        `pathname cannot contain \"${invalidCharacter}\", please encode it if needed`\n      );\n    }\n  }\n  const headers = {};\n  if (options.addRandomSuffix !== void 0) {\n    headers[\"x-add-random-suffix\"] = options.addRandomSuffix ? \"1\" : \"0\";\n  }\n  if (options.allowOverwrite !== void 0) {\n    headers[\"x-allow-overwrite\"] = options.allowOverwrite ? \"1\" : \"0\";\n  }\n  if (options.contentType) {\n    headers[\"x-content-type\"] = options.contentType;\n  }\n  if (options.cacheControlMaxAge !== void 0) {\n    headers[\"x-cache-control-max-age\"] = options.cacheControlMaxAge.toString();\n  }\n  const params = new URLSearchParams({\n    pathname: toPathname,\n    fromUrl: fromUrlOrPathname\n  });\n  const response = await requestApi(\n    `?${params.toString()}`,\n    {\n      method: \"PUT\",\n      headers,\n      signal: options.abortSignal\n    },\n    options\n  );\n  return {\n    url: response.url,\n    downloadUrl: response.downloadUrl,\n    pathname: response.pathname,\n    contentType: response.contentType,\n    contentDisposition: response.contentDisposition\n  };\n}\n\n// src/index.ts\nvar put = createPutMethod({\n  allowedOptions: [\n    \"cacheControlMaxAge\",\n    \"addRandomSuffix\",\n    \"allowOverwrite\",\n    \"contentType\"\n  ]\n});\nvar createMultipartUpload = createCreateMultipartUploadMethod({\n  allowedOptions: [\n    \"cacheControlMaxAge\",\n    \"addRandomSuffix\",\n    \"allowOverwrite\",\n    \"contentType\"\n  ]\n});\nvar createMultipartUploader = createCreateMultipartUploaderMethod({\n  allowedOptions: [\n    \"cacheControlMaxAge\",\n    \"addRandomSuffix\",\n    \"allowOverwrite\",\n    \"contentType\"\n  ]\n});\nvar uploadPart = createUploadPartMethod({\n  allowedOptions: [\n    \"cacheControlMaxAge\",\n    \"addRandomSuffix\",\n    \"allowOverwrite\",\n    \"contentType\"\n  ]\n});\nvar completeMultipartUpload = createCompleteMultipartUploadMethod({\n  allowedOptions: [\n    \"cacheControlMaxAge\",\n    \"addRandomSuffix\",\n    \"allowOverwrite\",\n    \"contentType\"\n  ]\n});\nexport {\n  BlobAccessError,\n  BlobClientTokenExpiredError,\n  BlobContentTypeNotAllowedError,\n  BlobError,\n  BlobFileTooLargeError,\n  BlobNotFoundError,\n  BlobPathnameMismatchError,\n  BlobRequestAbortedError,\n  BlobServiceNotAvailable,\n  BlobServiceRateLimited,\n  BlobStoreNotFoundError,\n  BlobStoreSuspendedError,\n  BlobUnknownError,\n  completeMultipartUpload,\n  copy,\n  createFolder,\n  createMultipartUpload,\n  createMultipartUploader,\n  del,\n  getDownloadUrl,\n  head,\n  list,\n  put,\n  uploadPart\n};\n//# sourceMappingURL=index.js.map"],"names":["isNodeProcess","type","Readable","isBuffer","obj","RetryOperation","timeouts","options","retry_operation","err","currentTime","timeout","self","fn","timeoutOps","counts","mainError","mainErrorCount","i","error","message","count","require$$0","exports","opts","key","a","b","attempt","random","methods","method","original","op","args","callback","retry","retrier","run","resolve","reject","bail","onError","num","runAttempt","val","lib","fetch","throttle","function_","wait","timeoutId","lastCallTime","arguments_","now","timeSinceLastCall","delayForNextCall","throttleit","supportsNewBlobFromArrayBuffer","helloAsArrayBuffer","text","toReadableStream","value","isNodeJsReadableStream","streamValue","isNodeJsBuffer","stringToUint8Array","controller","s","parseRegExp","map","bytes","results","floatValue","unit","res","unitMatch","defaultVercelBlobApiUrl","getTokenFromOptionsOrEnv","define_process_env_default","BlobError","isPlainObject","prototype","disallowedPathnameCharacters","supportsRequestStreams","getApiUrl","duplexAccessed","hasContentType","pathname","baseUrl","TEXT_ENCODER","computeBodyLength","body","createChunkTransformStream","chunkSize","onProgress","buffer","chunk","newBuffer","newChunk","isReadableStream","isStream","objectToString","isError","errorMessages","isNetworkError","debugIsActive","_a","_b","debug","hasFetch","hasFetchWithUploadProgress","CHUNK_SIZE","blobFetch","input","init","onUploadProgress","stream","loaded","chunkTransformStream","newLoaded","duplex","hasXhr","blobXhr","xhr","event","_a3","headers","line","parts","response","blobRequest","_a2","DOMException2","MAXIMUM_PATHNAME_LENGTH","BlobAccessError","BlobContentTypeNotAllowedError","BlobPathnameMismatchError","BlobClientTokenExpiredError","BlobFileTooLargeError","BlobStoreNotFoundError","BlobStoreSuspendedError","BlobUnknownError","BlobNotFoundError","BlobServiceNotAvailable","BlobServiceRateLimited","seconds","BlobRequestAbortedError","BLOB_API_VERSION","getApiVersion","versionOverride","getRetries","retries","createBlobServiceRateLimited","retryAfter","getBlobError","_b2","_c","code","data","requestApi","commandOptions","apiVersion","token","extraHeaders","getProxyThroughAlternativeApiHeaderFromEnv","storeId","requestId","retryCount","bodyLength","totalLoaded","sendBodyLength","shouldUseXContentLength","apiResponse","total","percentage","error2","putOptionHeaderMap","createPutHeaders","allowedOptions","createPutOptions","extraChecks","getToken","invalidCharacter","completeMultipartUpload","uploadId","params","createMultipartUpload","uploadPart","internalAbortController","part","responsePromise","handleAbort","maxConcurrentUploads","partSizeInBytes","maxBytesInMemory","uploadAllParts","totalToLoad","partsToUpload","completedParts","reader","activeUploads","reading","currentPartNumber","rejected","currentBytesInMemory","doneReading","bytesSent","arrayBuffers","currentPartBytesRead","totalLoadedPerPartNumber","acc","cur","read","cancel","done","sendParts","valueOffset","remainingPartSize","endOffset","sendPart","uploadProgressForPart","completedPart","partToSend","uncontrolledMultipartUpload","optionsWithoutOnUploadProgress","createMultipartUploadResponse","createPutMethod","optionsInput","throttle2","del","urlOrPathname","put"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10]}